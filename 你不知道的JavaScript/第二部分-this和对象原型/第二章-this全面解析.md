# 第二章 this全面解析

### 调用位置

- 调用栈:     函数调用的顺序(可以理解为,每个函数加一个console.log输出的顺序)
- 调用位置:   调用栈的顺序下,当前的前一个函数

### 绑定

- 默认绑定(优先级最低)

  - 在严格模式下,全局对象将无法使用默认绑定,因为this会绑定undefined

- 隐式绑定

  - 隐式绑定会把函数调用中的this绑定到这个上下文对象.(对象属性引用链最后一层影响调用位置)

    - ```javascript
      //隐式丢失
      function foo(){
        console.log(this.a)
      }
      var obj={
        a:2,
        foo:foo
      }
      var bar =obj.foo
      var a="aaa"//a是全局的属性,引用的是foo函数本身,变成默认绑定
      bar()//结果"aaa"bar()是一个不带任何修饰的函数调用
      ```

    - ```javascript
      function foo(){
        console.log(this.a)
      }
      function doFoo(fn){
        fn()
      }
      var obj={
        a:2,
        foo:foo
      }
      var a='aaa'//a是全局的属性
      doFoo(obj.foo)//'aaa'参数传递其实是一种隐式赋值,doFoo因为传参中隐式赋值的存在,依然是不带修饰的函数调用.
      ```

- 显式绑定(比隐式绑定高)

  - 想在某个对象上强制屌用函数,使用函数的call(...)和apply(...)方法.(它们的第一个参数是一个对象,他们会把这个对象绑定到this)这就是**显式绑定**
  - 通过foo.call(...),我们可以在调用foo时强制把它的this绑定到call()第一个参数上.
  - 如果你在call()传入一个原始值(字符串类型,布尔类型或者数字类型)来作为this的绑定对象,那么原始值会被转换成它的对象形式.这就是**装箱**
    - 硬绑定:使用call或apply绑定过的this,这是硬绑定,绑定完成以后不能修改
      - ES5中提供了内置的方法Function.prototype.bind

- new绑定(优先级最高)

  - JavaScript中new的机制和面向类的语言完全不同.其实new不存在所谓构造函数,只是习惯这么叫而已,**JS中所谓的构造函数只是被new操作符调用的普通函数而已 **
  - 1.创建(或者构造)一个全新的对象
  - 2.这个新对象会被执行[[原型]]连接
  - 3.这个新对象会绑定到函数调用的this
  - 4.如果函数没有返回其他对象,那么new表达式中的函数调用会自动返回这个心对象.

### 判断this

1. 判断函数是否在new中调用(new绑定)?如果是的话,this绑定的是新创建的对象
2. 函数是否通过call,apply(显式绑定)或者硬绑定调用?如果是的话,this绑定的是指定的对象
3. 函数是否在某个上下文对象中调用(隐式绑定)?如果是的话,this绑定的是哪个上下文对象.
4. 如果都不是的话,使用默认绑定.如果在严格模式,就绑定到undefined,否则绑定到全局对象.

### 绑定例外

- 被忽略的this
- 间接引用
- 软绑定

### this词法

ES6中箭头函数=>不适用this的四种标准规则,而是根据外层(函数或者全局)作用域来决定this.

self=this和箭头函数看上去可以取代bind(...),但是从本质上来说,他们想替代的是this机制.

### 总结

如果要判断一个运行中函数的this绑定,就需要找到这个函数的直接调用位置.找到之后就可以**顺序**应用下面这四条规则来判断this的绑定对象.

1. 由new调用?绑定到新创建的对象.
2. 由call或者apply(或者bind)调用?绑定到指定的对象.
3. 由上下文对象调用?绑定到那个上下文对象
4. 默认:在严格模式下绑定到undefined,否则绑定到全局对象.

一定要注意,有些调用可能在无意中使用默认绑定规则,如果想'更安全'地忽略this绑定,你可以使用一个DMZ对象

ES6中的箭头函数并不会使用四条标准的绑定规则,而是根据当前的词法作用域来决定this,具体来说,箭头函数会继承外层函数调用的this绑定(无论this绑定到什么).这其实和ES6之前代码self=this机制一样.